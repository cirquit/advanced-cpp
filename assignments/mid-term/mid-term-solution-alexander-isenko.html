<!DOCTYPE html><html><head><meta charset="utf-8"><style>@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAYcAA0AAAAACjQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABMAAAABwAAAAca8vGTk9TLzIAAAFMAAAARAAAAFZG1VHVY21hcAAAAZAAAAA+AAABQgAP9AdjdnQgAAAB0AAAAAQAAAAEACICiGdhc3AAAAHUAAAACAAAAAj//wADZ2x5ZgAAAdwAAADRAAABEKyikaNoZWFkAAACsAAAAC0AAAA2AtXoA2hoZWEAAALgAAAAHAAAACQHngNFaG10eAAAAvwAAAAQAAAAEAwAACJsb2NhAAADDAAAAAoAAAAKALIAVG1heHAAAAMYAAAAHwAAACABEAB2bmFtZQAAAzgAAALBAAAFu3I9x/Nwb3N0AAAF/AAAAB0AAAAvaoFvbwAAAAEAAAAAzBdyYwAAAADP2IQvAAAAAM/bz7t4nGNgZGFgnMDAysDB1Ml0hoGBoR9CM75mMGLkYGBgYmBlZsAKAtJcUxgcPsR8iGF2+O/AEMPsznAYKMwIkgMA5REMOXicY2BgYGaAYBkGRgYQsAHyGMF8FgYFIM0ChED+h5j//yEk/3KoSgZGNgYYk4GRCUgwMaACRoZhDwCs7QgGAAAAIgKIAAAAAf//AAJ4nHWMMQrCQBBF/0zWrCCIKUQsTDCL2EXMohYGSSmorScInsRGL2DOYJe0Ntp7BK+gJ1BxF1stZvjz/v8DRghQzEc4kIgKwiAppcA9LtzKLSkdNhKFY3HF4lK69ExKslx7Xa+vPRVS43G98vG1DnkDMIBUgFN0MDXflU8tbaZOUkXUH0+U27RoRpOIyCKjbMCVejwypzJJG4jIwb43rfl6wbwanocrJm9XFYfskuVC5K/TPyczNU7b84CXcbxks1Un6H6tLH9vf2LRnn8Ax7A5WQAAAHicY2BkYGAA4teL1+yI57f5ysDNwgAC529f0kOmWRiYVgEpDgYmEA8AUzEKsQAAAHicY2BkYGB2+O/AEMPCAAJAkpEBFbAAADgKAe0EAAAiAAAAAAQAAAAEAAAAAAAAKgAqACoAiAAAeJxjYGRgYGBhsGFgYgABEMkFhAwM/xn0QAIAD6YBhwB4nI1Ty07cMBS9QwKlQapQW3VXySvEqDCZGbGaHULiIQ1FKgjWMxknMfLEke2A+IJu+wntrt/QbVf9gG75jK577Lg8K1qQPCfnnnt8fX1NRC/pmjrk/zprC+8D7tBy9DHgBXoWfQ44Av8t4Bj4Z8CLtBL9CniJluPXASf0Lm4CXqFX8Q84dOLnMB17N4c7tBo1AS/Qi+hTwBH4rwHHwN8DXqQ30XXAS7QaLwSc0Gn8NuAVWou/gFmnjLrEaEh9GmDdDGgL3B4JsrRPDU2hTOiMSuJUIdKQQayiAth69r6akSSFqIJuA19TrzCIaY8sIoxyrNIrL//pw7A2iMygkX5vDj+G+kuoLdX4GlGK/8Lnlz6/h9MpmoO9rafrz7ILXEHHaAx95s9lsI7AHNMBWEZHULnfAXwG9/ZqdzLI08iuwRloXE8kfhXYAvE23+23DU3t626rbs8/8adv+9DWknsHp3E17oCf+Z48rvEQNZ78paYM38qfk3v/u3l3u3GXN2Dmvmvpf1Srwk3pB/VSsp512bA/GG5i2WJ7wu430yQ5K3nFGiOqgtmSB5pJVSizwaacmUZzZhXLlZTq8qGGFY2YcSkqbth6aW1tRmlaCFs2016m5qn36SbJrqosG4uMV4aP2PHBmB3tjtmgN2izkGQyLWprekbIntJFing32a5rKWCN/SdSoga45EJykyQ7asZvHQ8PTm6cslIpwyeyjbVltNikc2HTR7YKh9LBl9DADC0U/jLcBZDKrMhUBfQBvXRzLtFtjU9eNHKin0x5InTqb8lNpfKv1s1xHzTXRqgKzek/mb7nB8RZTCDhGEX3kK/8Q75AmUM/eLkfA+0Hi908Kx4eNsMgudg5GLdRD7a84npi+YxNr5i5KIbW5izXas7cHXIMAau1OueZhfj+cOcP3P8MNIWLyYOBuxL6DRylJ4cAAAB4nGNgYoAALjDJyIAOWMCiTIxMLDmZedkABtIBygAAAA==) format('woff');
}

* {
    box-sizing: border-box;
}

body {
    width: 980px;
    margin-right: auto;
    margin-left: auto;
}

body .markdown-body {
    padding: 45px;
    border: 1px solid #ddd;
    border-radius: 3px;
    word-wrap: break-word;
}

pre {
    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body {
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
  color: #333;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body strong {
  font-weight: bold;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body input {
  font: 13px / 1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
}

.markdown-body a {
  color: #4078c0;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before {
  display: table;
  content: "";
}

.markdown-body hr:after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body .select::-ms-expand {
  opacity: 0;
}

.markdown-body .octicon {
  font: normal normal normal 16px/1 octicons-anchor;
  display: inline-block;
  text-decoration: none;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.markdown-body .octicon-link:before {
  content: '\f05c';
}

.markdown-body:before {
  display: table;
  content: "";
}

.markdown-body:after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body .anchor {
  display: inline-block;
  padding-right: 2px;
  margin-left: -18px;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #000;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h1 .anchor {
  line-height: 1;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 .anchor {
  line-height: 1;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h3 .anchor {
  line-height: 1.2;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h4 .anchor {
  line-height: 1.2;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h5 .anchor {
  line-height: 1.1;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body h6 .anchor {
  line-height: 1.1;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  box-sizing: content-box;
  background-color: #fff;
}

.markdown-body code {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .pl-c {
  color: #969896;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #0086b3;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #795da3;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
  color: #333;
}

.markdown-body .pl-ent {
  color: #63a35c;
}

.markdown-body .pl-k {
  color: #a71d5d;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
  color: #183691;
}

.markdown-body .pl-v {
  color: #ed6a43;
}

.markdown-body .pl-id {
  color: #b52a1d;
}

.markdown-body .pl-ii {
  background-color: #b52a1d;
  color: #f8f8f8;
}

.markdown-body .pl-sr .pl-cce {
  color: #63a35c;
  font-weight: bold;
}

.markdown-body .pl-ml {
  color: #693a17;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  color: #1d3e81;
  font-weight: bold;
}

.markdown-body .pl-mq {
  color: #008080;
}

.markdown-body .pl-mi {
  color: #333;
  font-style: italic;
}

.markdown-body .pl-mb {
  color: #333;
  font-weight: bold;
}

.markdown-body .pl-md {
  background-color: #ffecec;
  color: #bd2c00;
}

.markdown-body .pl-mi1 {
  background-color: #eaffea;
  color: #55a532;
}

.markdown-body .pl-mdr {
  color: #795da3;
  font-weight: bold;
}

.markdown-body .pl-mo {
  color: #1d3e81;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .plan-price-unit {
  color: #767676;
  font-weight: normal;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 0.35em 0.25em -1.6em;
  vertical-align: middle;
}

.markdown-body .plan-choice {
  padding: 15px;
  padding-left: 40px;
  display: block;
  border: 1px solid #e0e0e0;
  position: relative;
  font-weight: normal;
  background-color: #fafafa;
}

.markdown-body .plan-choice.open {
  background-color: #fff;
}

.markdown-body .plan-choice.open .plan-choice-seat-breakdown {
  display: block;
}

.markdown-body .plan-choice-free {
  border-radius: 3px 3px 0 0;
}

.markdown-body .plan-choice-paid {
  border-radius: 0 0 3px 3px;
  border-top: 0;
  margin-bottom: 20px;
}

.markdown-body .plan-choice-radio {
  position: absolute;
  left: 15px;
  top: 18px;
}

.markdown-body .plan-choice-exp {
  color: #999;
  font-size: 12px;
  margin-top: 5px;
}

.markdown-body .plan-choice-seat-breakdown {
  margin-top: 10px;
  display: none;
}

.markdown-body :checked+.radio-label {
  z-index: 1;
  position: relative;
  border-color: #4078c0;
}
</style><title>mid-term-solution-alexander-isenko</title></head><body><article class="markdown-body"><h2>
<a id="user-content-midterm-assignment---alexander-isenko" class="anchor" href="#midterm-assignment---alexander-isenko" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Midterm Assignment - Alexander Isenko</h2>

<h3>
<a id="user-content-1-types-classes-objects-and-their-state" class="anchor" href="#1-types-classes-objects-and-their-state" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1. Types, Classes, Objects and their State</h3>

<h4>
<a id="user-content-11-object-definition" class="anchor" href="#11-object-definition" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.1 Object Definition</h4>

<blockquote>
<p>Assuming your are confronted with a class that supports the following use case:</p>

<div class="highlight highlight-source-c++"><pre>DateParser date_parser;
date_parser.set_date(today);

<span class="pl-k">auto</span> day = date_parser.day_of_week()</pre></div>

<p>Q: What is your objection to this? How would you change the interface of class <code>DateParser</code>?</p>
</blockquote>

<p><strong>Answer:</strong> The method <code>day_of_week</code> is not valid without the previous <code>set_date</code> call.
I would enforce to use a constructor with the argument <code>today</code>.</p>

<h4>
<a id="user-content-12-standard-object-semantics" class="anchor" href="#12-standard-object-semantics" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.2 Standard Object Semantics</h4>

<blockquote>
<p>Given the following implementation of class <code>SemanticSurprise</code>:</p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">class</span> <span class="pl-en">SemanticSurprise</span> {
<span class="pl-k">public:</span>

  <span class="pl-en">SemanticSurprise</span>(<span class="pl-k">int</span> value)
  : _value(value) { }

  <span class="pl-en">SemanticSurprise</span>(<span class="pl-k">const</span> SemanticSurprise &amp; other)
  : _value(other._value) { } 

  <span class="pl-k">bool</span> <span class="pl-k">operator</span>==(<span class="pl-k">const</span> SemanticSurprise &amp; other) <span class="pl-k">const</span> {
    <span class="pl-k">return</span> _value == other.<span class="pl-smi">_value</span>;
  }

  <span class="pl-k">int</span> <span class="pl-en">value</span>() {
    <span class="pl-k">return</span> _value;
  }

<span class="pl-k">private:</span>
  <span class="pl-k">int</span> _value;
};</pre></div>

<p>Q: Are there any compiler errors? If so: why?</p>
</blockquote>

<p><strong>Answer:</strong> There are none. (The following code was not included in this answer)</p>

<blockquote>
<div class="highlight highlight-source-c++"><pre><span class="pl-c1">1</span>  SemanticSurprise s1;          <span class="pl-c"><span class="pl-c">//</span> &lt;-- Op?</span>
<span class="pl-c1">2</span>  s1.value();                   <span class="pl-c"><span class="pl-c">//</span> &lt;-- value?</span>
<span class="pl-c1">3</span>
<span class="pl-c1">4</span>  SemanticSurprise <span class="pl-en">s2</span>(<span class="pl-c1">4</span>);       <span class="pl-c"><span class="pl-c">//</span> &lt;-- Op?</span>
<span class="pl-c1">5</span>  s2.value();                   <span class="pl-c"><span class="pl-c">//</span> &lt;-- value?</span>
<span class="pl-c1">6</span>
<span class="pl-c1">7</span>  SemanticSurprise s3 = s2;     <span class="pl-c"><span class="pl-c">//</span> &lt;-- Op?</span>
<span class="pl-c1">8</span>  s3.value();                   <span class="pl-c"><span class="pl-c">//</span> &lt;-- value?</span>
<span class="pl-c1">9</span>
<span class="pl-c1">10</span> SemanticSurprise <span class="pl-en">s4</span>(s3);      <span class="pl-c"><span class="pl-c">//</span> &lt;-- Op?</span>
<span class="pl-c1">11</span> s4 == s3;                     <span class="pl-c"><span class="pl-c">//</span> &lt;-- value?</span>
<span class="pl-c1">12</span> s2 != s3;                     <span class="pl-c"><span class="pl-c">//</span> &lt;-- value?</span></pre></div>

<p>Q: Name the method/operation on SemanticSurprise in every line marked with Op?, including those that lead to compiler errors.</p>
</blockquote>

<p><strong>Answer:</strong> </p>

<ul>
<li>Line 1, there is a default constructor missing (compile error)</li>
<li>Line 4, the custom constructor is called</li>
<li>Line 7, s3 is allocated, copy constructor is called</li>
<li>Line 10, copy constructor is called</li>
</ul>

<blockquote>
<p>Q: Which values are returned in the lines marked with value? (given the line does not lead to a compiler error). Explain why these values are returned.</p>
</blockquote>

<p><strong>Answer:</strong></p>

<ul>
<li>Line 2, if this would compile, it should return garbage. (not specified in standart, <code>g++</code> returns garbage, <code>clang++</code> returns <code>0</code>)</li>
<li>Line 5, returns <code>4</code>
</li>
<li>Line 8, returns <code>4</code>, because the copy constructor got the value from <code>s2</code>
</li>
<li>Line 11, returns <code>1</code>, stands for <code>true</code>
</li>
<li>Line 12, returns <code>0</code>, if this would compile and derive the <code>operator!=</code> from <code>operator==</code>
</li>
</ul>

<blockquote>
<p>Q: How can this implementation be simplified? What is the requirement for this simplification?</p>
</blockquote>

<p><strong>Answer:</strong></p>

<p>We could remove the explicit copy constructor (see Rule of Zero).
If we would want that everything compiles, we have to create a constructor and an <code>operator!=</code>:  <a href="/Users/rewrite/Documents/university/master/semester-01/soft-dev/advanced-cpp/assignments/mid-term/1-2/1-2.cc">Code</a></p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">class</span> <span class="pl-en">SemanticSurprise</span> {
<span class="pl-k">public:</span>

  <span class="pl-en">SemanticSurprise</span>()
  : _value(<span class="pl-c1">0</span>) { }

  <span class="pl-en">SemanticSurprise</span>(<span class="pl-k">int</span> value)
  : _value(value) { }

  <span class="pl-k">bool</span> <span class="pl-k">operator</span>==(<span class="pl-k">const</span> SemanticSurprise &amp; other) <span class="pl-k">const</span> {
    <span class="pl-k">return</span> _value == other.<span class="pl-smi">_value</span>;
  }

  <span class="pl-k">bool</span> <span class="pl-k">operator</span>!=(<span class="pl-k">const</span> SemanticSurprise &amp; other) <span class="pl-k">const</span> {
    <span class="pl-k">return</span> !(*<span class="pl-c1">this</span> == other);
  }

  <span class="pl-k">int</span> <span class="pl-en">value</span>() {
    <span class="pl-k">return</span> _value;
  }

<span class="pl-k">private:</span>
  <span class="pl-k">int</span> _value;
};</pre></div>

<blockquote>
<p>Given the implementation of SemanticSurprise above, the following use case leads to a compiler error:</p>

<blockquote>
<div class="highlight highlight-source-c++"><pre><span class="pl-k">void</span> <span class="pl-en">print_surprise</span>(<span class="pl-k">const</span> SemanticSurprise &amp; s) {
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>SemanticSurprise.value: <span class="pl-pds">"</span></span> &lt;&lt; s.<span class="pl-c1">value</span>() &lt;&lt; std::endl;
}
<span class="pl-en">print_surprise</span>(SemanticSurprise(<span class="pl-c1">10</span>));</pre></div>
</blockquote>

<p>Q: Explain the compiler error and how the implementation of SemanticSurprise has to be corrected.</p>
</blockquote>

<p><strong>Answer:</strong></p>

<p>The problem is the <code>const</code> identifier in the argument of <code>print_surprise</code>. We call <code>value()</code> in this function and the compiler can't be sure that this doesn't modify the object. We have to append the <code>const</code> keyword to signal the compiler that the use of this function does not change the object in any way. <a href="/Users/rewrite/Documents/university/master/semester-01/soft-dev/advanced-cpp/assignments/mid-term/1-2/1-2.cc">Code</a></p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">class</span> <span class="pl-en">SemanticSurprise</span> {
<span class="pl-k">public:</span>
...
  <span class="pl-k">int</span> <span class="pl-en">value</span>() <span class="pl-k">const</span> {
    <span class="pl-k">return</span> _value;
  }
...</pre></div>

<h4>
<a id="user-content-13-resource-ownership" class="anchor" href="#13-resource-ownership" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.3 Resource Ownership</h4>

<blockquote>
<p>Consider the following use case:</p>

<div class="highlight highlight-source-c++"><pre><span class="pl-c"><span class="pl-c">//</span> ...</span>
<span class="pl-k">if</span> (condition) {
        LogFileReader <span class="pl-smi">log_reader</span>(<span class="pl-s"><span class="pl-pds">"</span>performance.log<span class="pl-pds">"</span></span>);
        <span class="pl-k">if</span> (log_reader.<span class="pl-c1">lines</span>().<span class="pl-c1">size</span>() &gt; <span class="pl-c1">1024</span>) { <span class="pl-k">return</span>; }
}
<span class="pl-c"><span class="pl-c">//</span> ...</span></pre></div>

<p>Q: Judging from its usage illustrated above: which rule must be satisfied in the implementation of class LogFileReader (or one of its members)?</p>
</blockquote>

<p><strong>Answer:</strong>
The Rule of Zero/Three/Five should be satisfied, because if an exception happens after the <code>LogFileReader</code> aquired the resource <code>"performance.log"</code> it should release it without a doubt. If the destructor it not defined properly, this leads to resource leaks.</p>

<blockquote>
<p>Q: Name a popular technique in resource management that depends on this rule, and briefly explain its principle.</p>
</blockquote>

<p><strong>Answer:</strong>
This technique/iodom is called <strong>RAII</strong> (<em>Resource acquisition is initialization</em>) and states that resource allocation happens in the initialization phase and the release of resources happens by the destructor. This means that if there are no object leaks, there aren't any resource leaks.</p>

<h4>
<a id="user-content-1x-bonus" class="anchor" href="#1x-bonus" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.X Bonus</h4>

<blockquote>
<p>Have a look at this example code from the lecture “CMSC 12300 - Computer Science with Applications 3” at University of Chicago:</p>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">"</span>basefrequentflyer.h<span class="pl-pds">"</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">"</span>frequentflyer.h<span class="pl-pds">"</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">"</span>silverfrequentflyer.h<span class="pl-pds">"</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">"</span>goldfrequentflyer.h<span class="pl-pds">"</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
  BaseFrequentFlyer* f[<span class="pl-c1">3</span>];

  f[<span class="pl-c1">0</span>] = <span class="pl-k">new</span> <span class="pl-c1">FrequentFlyer</span> (<span class="pl-s"><span class="pl-pds">"</span>Cornelius Doe<span class="pl-pds">"</span></span>, <span class="pl-c1">23166841</span>, <span class="pl-c1">100</span>);
  f[<span class="pl-c1">1</span>] = <span class="pl-k">new</span> <span class="pl-c1">SilverFrequentFlyer</span> (<span class="pl-s"><span class="pl-pds">"</span>Lucius Doe<span class="pl-pds">"</span></span>, <span class="pl-c1">94565432</span>, <span class="pl-c1">100</span>, <span class="pl-c1">5</span>);
  f[<span class="pl-c1">2</span>] = <span class="pl-k">new</span> <span class="pl-c1">GoldFrequentFlyer</span>(<span class="pl-s"><span class="pl-pds">"</span>Rufus Doe<span class="pl-pds">"</span></span>, <span class="pl-c1">32155994</span>, <span class="pl-c1">100</span>, <span class="pl-c1">100</span>);

  f[<span class="pl-c1">0</span>]-&gt;<span class="pl-c1">addMiles</span>(<span class="pl-c1">100</span>);
  f[<span class="pl-c1">1</span>]-&gt;<span class="pl-c1">addMiles</span>(<span class="pl-c1">100</span>);
  f[<span class="pl-c1">2</span>]-&gt;<span class="pl-c1">addMiles</span>(<span class="pl-c1">100</span>);

  f[<span class="pl-c1">0</span>]-&gt;<span class="pl-c1">printData</span>();
  f[<span class="pl-c1">1</span>]-&gt;<span class="pl-c1">printData</span>();
  f[<span class="pl-c1">2</span>]-&gt;<span class="pl-c1">printData</span>();

  <span class="pl-k">delete</span> f[<span class="pl-c1">0</span>];
  <span class="pl-k">delete</span> f[<span class="pl-c1">1</span>];
  <span class="pl-k">delete</span> f[<span class="pl-c1">2</span>];
}</pre></div>

<p>Q: Do you have any objections? Improve the implementation.</p>
</blockquote>

<p><strong>Answer</strong></p>

<p>This would be my implementation: <a href="/Users/rewrite/Documents/university/master/semester-01/soft-dev/advanced-cpp/assignments/mid-term/1-X/1-X.cc">Code</a></p>

<div class="highlight highlight-source-c++"><pre><span class="pl-c"><span class="pl-c">//</span> some boilerplate to check validity</span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>vector<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>algorithm<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>string<span class="pl-pds">&gt;</span></span>

<span class="pl-k">class</span> <span class="pl-en">BaseFrequentFlyer</span> {
<span class="pl-k">public:</span>

  <span class="pl-en">BaseFrequentFlyer</span>()
  : _name(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)
  , _number(<span class="pl-c1">0</span>)
  , _miles(<span class="pl-c1">0</span>) { }

  <span class="pl-en">BaseFrequentFlyer</span>(std::string name, <span class="pl-k">int</span> number, <span class="pl-k">int</span> miles)
  : _name(name)
  , _number(number)
  , _miles(miles) { }

  <span class="pl-k">void</span> <span class="pl-en">addMiles</span> ( <span class="pl-k">int</span> realMiles ) { _miles += realMiles; }
  <span class="pl-k">void</span> <span class="pl-en">printData</span> ()
  {
      std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Name: <span class="pl-pds">"</span></span> &lt;&lt; _name &lt;&lt; std::endl;
      std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Number: <span class="pl-pds">"</span></span> &lt;&lt; _number &lt;&lt; std::endl;
      std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Miles: <span class="pl-pds">"</span></span> &lt;&lt; _miles &lt;&lt; std::endl;
  }

<span class="pl-k">protected:</span>
  std::string _name;
  <span class="pl-k">int</span>         _number;
  <span class="pl-k">int</span>         _miles;

};

<span class="pl-k">class</span> <span class="pl-en">FrequentFlyer</span> : <span class="pl-k">public</span> <span class="pl-en">BaseFrequentFlyer</span> {
<span class="pl-k">public:</span>
  <span class="pl-en">FrequentFlyer</span>(std::string name, <span class="pl-k">int</span> number, <span class="pl-k">int</span> miles)
  : BaseFrequentFlyer(name, number, miles) { }
};

<span class="pl-k">class</span> <span class="pl-en">SilverFrequentFlyer</span> : <span class="pl-k">public</span> <span class="pl-en">FrequentFlyer</span> {
<span class="pl-k">public:</span>
  <span class="pl-en">SilverFrequentFlyer</span>(std::string name, <span class="pl-k">int</span> number, <span class="pl-k">int</span> miles, <span class="pl-k">int</span> years)
  : FrequentFlyer(name, number, miles), _years(years) { }

<span class="pl-k">private:</span>
  <span class="pl-k">int</span> _years;
};

<span class="pl-k">class</span> <span class="pl-en">GoldFrequentFlyer</span> : <span class="pl-k">public</span> <span class="pl-en">FrequentFlyer</span> {
<span class="pl-k">public:</span>
  <span class="pl-en">GoldFrequentFlyer</span>(std::string name, <span class="pl-k">int</span> number, <span class="pl-k">int</span> miles, <span class="pl-k">int</span> years)
  : FrequentFlyer(name, number, miles), _years(years) { }

<span class="pl-k">private:</span>
  <span class="pl-k">int</span> _years;
};

<span class="pl-c"><span class="pl-c">//</span> implementation starts here</span>

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    std::vector&lt;BaseFrequentFlyer&gt; f { <span class="pl-c1">FrequentFlyer</span> (<span class="pl-s"><span class="pl-pds">"</span>Cornelius Doe<span class="pl-pds">"</span></span>, <span class="pl-c1">23166841</span>, <span class="pl-c1">100</span>)
                                     , <span class="pl-c1">SilverFrequentFlyer</span> (<span class="pl-s"><span class="pl-pds">"</span>Lucius Doe<span class="pl-pds">"</span></span>, <span class="pl-c1">94565432</span>, <span class="pl-c1">100</span>, <span class="pl-c1">5</span>)
                                     , <span class="pl-c1">GoldFrequentFlyer</span>(<span class="pl-s"><span class="pl-pds">"</span>Rufus Doe<span class="pl-pds">"</span></span>, <span class="pl-c1">32155994</span>, <span class="pl-c1">100</span>, <span class="pl-c1">100</span>) };

    <span class="pl-c1">for_each</span>(f.<span class="pl-c1">begin</span>()
           , f.<span class="pl-c1">end</span>()
           , [](BaseFrequentFlyer &amp; flyer)
           {
             flyer.<span class="pl-c1">addMiles</span>(<span class="pl-c1">100</span>);
             flyer.<span class="pl-c1">printData</span>();
           });
}</pre></div>

<blockquote>
<p>Q: Also: what is the most important guideline on the use of new and delete that comes to your mind? (hint: session 02)</p>
</blockquote>

<p><strong>Answer</strong>: Never use <code>new</code> and <code>delete</code>. Follow the Rule of Zero/Three/Five.</p>

<h3>
<a id="user-content-2-container-types-class-template-basics" class="anchor" href="#2-container-types-class-template-basics" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2. Container Types, Class Template Basics</h3>

<h3>
<a id="user-content-3-iterators" class="anchor" href="#3-iterators" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3. Iterators</h3>

<h4>
<a id="user-content-31-algorithm-basics" class="anchor" href="#31-algorithm-basics" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.1 Algorithm Basics</h4>

<blockquote>
<p>The following algorithm dereferences and returns a given iterator’s successor unless the successor’s referenced value matches some condition. The algorithm is semantically correct but does not compile for iterators of some containers.</p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> Iterator, <span class="pl-k">typename</span> Value = <span class="pl-k">typename</span> Iterator::value_type&gt;
Value <span class="pl-en">next_value_or_default</span>(Iterator it, Iterator end, Value <span class="pl-k">default</span>) {
  <span class="pl-k">if</span> (it == end || it+<span class="pl-c1">1</span> == end) { <span class="pl-k">return</span> <span class="pl-k">default</span>; }
  <span class="pl-k">return</span> it[<span class="pl-c1">1</span>];
}</pre></div>

<p>Q: Which containers? Briefly explain why the algorithm does not work for these and how it has to be changed.</p>
</blockquote>

<p><strong>Answer</strong>:
We need at least a <code>RandomAccessIterator</code>, because we make use of <code>it+1</code> and <code>it[1]</code>. Does not compile for</p>

<ul>
<li><code>istream</code></li>
<li><code>ostream</code></li>
<li><code>inserter</code></li>
<li><code>forward_list</code></li>
<li><code>unordered_map</code></li>
<li><code>unordered_set</code></li>
<li><code>list</code></li>
</ul>

<p>The code should be changed to:</p>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iterator<span class="pl-pds">&gt;</span></span>

<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> Iterator, <span class="pl-k">typename</span> Value = <span class="pl-k">typename</span> Iterator::value_type&gt;
Value <span class="pl-en">next_value_or_default</span>(Iterator it, Iterator end, Value <span class="pl-k">default</span>) {
  <span class="pl-c1">std::advance</span>(it, <span class="pl-c1">1</span>);
  <span class="pl-k">if</span> (it == end ) { <span class="pl-k">return</span> <span class="pl-k">default</span>; }
  <span class="pl-k">return</span> *it;
}</pre></div>

<h4>
<a id="user-content-32-container-wrapper" class="anchor" href="#32-container-wrapper" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.2 Container Wrapper</h4>

<blockquote>
<p>The STL’s <code>std::vector</code> guarantess that its elements are stored in a contiguous memory region and is therefore compatible to C-style arrays. The member function .data() returns a pointer to the vector’s underlying raw memory.</p>

<p>For many hardware-tuning techniques, data is accessed in chunks. Assuming a <code>std::vector&lt;uint32_t&gt;</code> and 64 bytes per cache line, for example, vector elements could be loaded in chunks of 64/(32/8) = 16 elements.</p>

<p>Write a container wrapper <code>cpppc::chunks&lt;B, T, Container&gt;</code> that provides a sequential container interface on elements in Container in chunks of maximum size B bytes.</p>
</blockquote>

<p><strong>Answer</strong>:</p>

<p>I interpreted the question in two different ways, one was a "cached vector", which feels like a vector, but stores the data in fixed sized arrays to caching can take place <a href="/Users/rewrite/Documents/university/master/semester-01/soft-dev/advanced-cpp/assignments/mid-term/3-2/elements-iterator/chunks.h">chunks.h</a> and <a href="/Users/rewrite/Documents/university/master/semester-01/soft-dev/advanced-cpp/assignments/mid-term/3-2/elements-iterator/main.cc">main.cc</a>. The solution which works for the predefined code (which had to be adjusted a little) is found here <a href="/Users/rewrite/Documents/university/master/semester-01/soft-dev/advanced-cpp/assignments/mid-term/3-2/chunks-iterator/chunks.h">chunks.h</a> and <a href="/Users/rewrite/Documents/university/master/semester-01/soft-dev/advanced-cpp/assignments/mid-term/3-2/chunks-iterator/main.cc">main.cc</a>.</p>

<p>This is the second solution:</p>

<div class="highlight highlight-source-c++"><pre>
#<span class="pl-k">ifndef</span> CPPPC__CHUNKS_H__INCLUDED
#<span class="pl-k">define</span> <span class="pl-en">CPPPC__CHUNKS_H__INCLUDED</span>

#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>vector<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>array<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>cstdlib<span class="pl-pds">&gt;</span></span>

<span class="pl-k">namespace</span> <span class="pl-en">cpppc</span> {

<span class="pl-k">namespace</span> <span class="pl-en">detail</span> {

<span class="pl-k">template </span>&lt;<span class="pl-k">class</span> <span class="pl-en">ContainerT</span>&gt;
<span class="pl-k">class</span> <span class="pl-en">delegate_iterator</span>
{
<span class="pl-k">public:</span>

  <span class="pl-k">using</span> <span class="pl-c1">self_t</span>          = delegate_iterator&lt;ContainerT&gt;;
  <span class="pl-k">using</span> <span class="pl-c1">element_t</span>       = <span class="pl-k">typename</span> ContainerT::value_type;

  <span class="pl-k">using</span> iterator_category = std::random_access_iterator_tag;
  <span class="pl-k">using</span> difference_type   = <span class="pl-k">typename</span> ContainerT::difference_type;
  <span class="pl-k">using</span> value_type        = <span class="pl-c1">element_t</span>;
  <span class="pl-k">using</span> pointer           = <span class="pl-c1">element_t</span> *;
  <span class="pl-k">using</span> reference         = <span class="pl-c1">element_t</span> &amp;;

<span class="pl-k">public:</span>
   <span class="pl-en">delegate_iterator</span>() = <span class="pl-k">delete</span>;
   <span class="pl-en">delegate_iterator</span>(ContainerT &amp; container)
   : _container(container)
   , _pos(<span class="pl-c1">0</span>) <span class="pl-c"><span class="pl-c">//</span> a chunk.begin() starts always at the first position,</span>
             <span class="pl-c"><span class="pl-c">//</span> even if it was already traversed a bit in the previous iterator</span>
   { }

<span class="pl-k">public:</span>

  <span class="pl-k">inline</span> <span class="pl-c1">element_t</span> &amp; <span class="pl-k">operator</span>*()
  {
    <span class="pl-k">return</span> _container[_pos];
  }

<span class="pl-c"><span class="pl-c">//</span> ... generic iterator stuff, like ++, ==, etc.</span>

<span class="pl-k">private:</span>
  ContainerT &amp;    _container;
  difference_type _pos;
};


<span class="pl-k">template </span>&lt;<span class="pl-k">class</span> <span class="pl-en">ChunksT</span>&gt;
<span class="pl-k">class</span> <span class="pl-en">chunks_iterator</span>
{
<span class="pl-k">public:</span>
  <span class="pl-k">using</span> <span class="pl-c1">self_t</span>          = chunks_iterator&lt;ChunksT&gt;;
  <span class="pl-k">using</span> <span class="pl-c1">element_t</span>       = <span class="pl-k">typename</span> ChunksT::<span class="pl-c1">chunk_t</span>;

  <span class="pl-k">using</span> iterator_category = std::random_access_iterator_tag;
  <span class="pl-k">using</span> difference_type   = <span class="pl-k">typename</span> ChunksT::difference_type;
  <span class="pl-k">using</span> value_type        = <span class="pl-c1">element_t</span>;
  <span class="pl-k">using</span> pointer           = <span class="pl-c1">element_t</span> *;
  <span class="pl-k">using</span> reference         = <span class="pl-c1">element_t</span> &amp;;

<span class="pl-k">public:</span>
  <span class="pl-k">using</span> iterator           = delegate_iterator&lt;<span class="pl-c1">element_t</span>&gt;;
  <span class="pl-k">using</span> <span class="pl-c1">inner_element_t</span>    = <span class="pl-k">typename</span> ChunksT::<span class="pl-c1">value_t</span>;
  <span class="pl-k">using</span> <span class="pl-c1">inner_difference_t</span> = <span class="pl-k">typename</span> ChunksT::<span class="pl-c1">index_t</span>;

  <span class="pl-k">friend</span> iterator;

<span class="pl-k">public:</span>
  <span class="pl-en">chunks_iterator</span>() = <span class="pl-k">delete</span>;
  <span class="pl-en">chunks_iterator</span>(ChunksT &amp; chunks, difference_type pos)
  : _chunks(chunks)
  , _pos(pos) { }


<span class="pl-k">public:</span>
  <span class="pl-k">inline</span> <span class="pl-c1">element_t</span> &amp; <span class="pl-k">operator</span>*()
  {
    <span class="pl-c1">element_t</span> &amp; chunk = _chunks.<span class="pl-smi">_chunks</span>[_pos];
    <span class="pl-k">return</span> chunk;
  }

<span class="pl-c"><span class="pl-c">//</span> ... generic iterator stuff, like ++, ==, etc.</span>

  iterator <span class="pl-en">begin</span>() <span class="pl-k">const</span> {
    <span class="pl-k">return</span> <span class="pl-c1">iterator</span>(_chunks.<span class="pl-smi">_chunks</span>[_pos]);
  }

  iterator <span class="pl-en">end</span>() <span class="pl-k">const</span> {
    <span class="pl-k">return</span> <span class="pl-c1">iterator</span>(_chunks.<span class="pl-smi">_chunks</span>[_pos]);
  }

  <span class="pl-k">inline</span> <span class="pl-c1">inner_element_t</span> <span class="pl-k">operator</span>[](<span class="pl-k">int</span> offset) <span class="pl-k">const</span> {
    <span class="pl-k">return</span> *(<span class="pl-c1">begin</span>() + offset);
  }

<span class="pl-k">private:</span>
<span class="pl-c"><span class="pl-c">//</span>  this can be used to calculate the offsetted beginning of the chunks, if needed</span>
<span class="pl-c"><span class="pl-c">//</span>  const std::ldiv_t get_current_chunk_info() const</span>
<span class="pl-c"><span class="pl-c">//</span>  {</span>
<span class="pl-c"><span class="pl-c">//</span>    return std::div(static_cast&lt;long&gt;(_pos), static_cast&lt;long&gt;(_max_bounds));</span>
<span class="pl-c"><span class="pl-c">//</span>  }</span>

<span class="pl-k">private:</span>
  ChunksT &amp;       _chunks;
  difference_type _pos = <span class="pl-c1">0</span>;
};

}; <span class="pl-c"><span class="pl-c">//</span> namespace detail</span>

<span class="pl-k">template </span>&lt;std::<span class="pl-c1">size_t</span> B, <span class="pl-k">class</span> <span class="pl-en">T</span>, <span class="pl-k">class</span> <span class="pl-en">Container</span>&gt;
<span class="pl-k">class</span> <span class="pl-en">chunks</span>
{

<span class="pl-k">public:</span>
  <span class="pl-k">using</span> <span class="pl-c1">self_t</span>          = chunks&lt;B, T, Container&gt;;

  <span class="pl-k">using</span> <span class="pl-c1">chunk_t</span>         = std::array&lt;T,B&gt;;
  <span class="pl-k">using</span> chunk_ref       = <span class="pl-c1">chunk_t</span> &amp;;
  <span class="pl-k">using</span> chunk_const_ref = <span class="pl-k">const</span> <span class="pl-c1">chunk_t</span> &amp;;
  <span class="pl-k">using</span> <span class="pl-c1">chunk_index_t</span>   = <span class="pl-c1">size_t</span>;

  <span class="pl-k">using</span> <span class="pl-c1">value_t</span>         = T;
  <span class="pl-k">using</span> reference       = T &amp;;
  <span class="pl-k">using</span> const_reference = <span class="pl-k">const</span> T &amp;;
  <span class="pl-k">using</span> <span class="pl-c1">index_t</span>         = <span class="pl-c1">size_t</span>;

<span class="pl-k">public:</span>
  <span class="pl-k">using</span> iterator        = detail::chunks_iterator&lt;<span class="pl-c1">self_t</span>&gt;;
  <span class="pl-k">using</span> difference_type = <span class="pl-c1">chunk_index_t</span>;

  <span class="pl-k">friend</span> iterator;

<span class="pl-k">public:</span>
  <span class="pl-en">chunks</span>(Container container)
  { 
    <span class="pl-k">int</span> i = <span class="pl-c1">0</span>;
    <span class="pl-c1">std::for_each</span>(container.<span class="pl-c1">begin</span>()
                 ,container.<span class="pl-c1">end</span>()
                 ,[&amp;](T &amp; item){

                    <span class="pl-k">if</span> (_chunks.<span class="pl-c1">empty</span>() ||  i &gt;= B)
                    { 
                      _chunks.<span class="pl-c1">push_back</span>(std::array&lt;T, B&gt; {{ item }});
                      std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Created new array with: <span class="pl-pds">"</span></span> &lt;&lt; item &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
                      i = <span class="pl-c1">1</span>;
                    } <span class="pl-k">else</span>
                    {
                      _chunks.<span class="pl-c1">back</span>()[i] = item;
                      std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Appended to array: <span class="pl-pds">"</span></span> &lt;&lt; item &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
                      ++i;
                    }
                  });

    _end = <span class="pl-c1">iterator</span>(*<span class="pl-c1">this</span>, _chunks.<span class="pl-c1">size</span>());
  }

  iterator <span class="pl-en">begin</span>() { <span class="pl-k">return</span> _begin; }
  iterator <span class="pl-en">end</span>()   { <span class="pl-k">return</span> _end;   }

  <span class="pl-k">inline</span> <span class="pl-c1">chunk_t</span> <span class="pl-k">operator</span>[](<span class="pl-k">int</span> offset) <span class="pl-k">const</span> {
    <span class="pl-k">return</span> _chunks[offset];
  }

<span class="pl-k">private:</span>
  std::vector&lt;std::array&lt;T,B&gt;&gt; _chunks;

  iterator _begin = iterator(*<span class="pl-c1">this</span>, <span class="pl-c1">0</span>);
  iterator _end   = iterator(*<span class="pl-c1">this</span>, <span class="pl-c1">0</span>);
};

} <span class="pl-c"><span class="pl-c">//</span> namespace cppp</span>

#<span class="pl-k">endif</span></pre></div>

<p><code>main.cc</code></p>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>vector<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>cstdint<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>algorithm<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>chunks.h<span class="pl-pds">"</span></span>

#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>vector<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
  <span class="pl-k">using</span> chunked_container = <span class="pl-k">typename</span> cpppc::chunks&lt;<span class="pl-c1">2</span>, <span class="pl-c1">uint16_t</span>, std::vector&lt;<span class="pl-c1">uint16_t</span>&gt;&gt;;

  std::vector&lt;<span class="pl-c1">uint16_t</span>&gt; v_us { <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span> };

  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>-- Creation: -- <span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
  chunked_container <span class="pl-smi">v_chunks</span>(v_us);

  <span class="pl-c"><span class="pl-c">//</span> Iterate chunks:</span>
  <span class="pl-k">auto</span> first_chunk = v_chunks.<span class="pl-c1">begin</span>();

  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>-- Iterating through with custom for: <span class="pl-pds">"</span></span>;
  <span class="pl-k">for</span>(<span class="pl-k">auto</span> it = first_chunk; it != v_chunks.<span class="pl-c1">end</span>(); ++it)
  {
      <span class="pl-k">for</span> (<span class="pl-k">auto</span> iit = (*it).<span class="pl-c1">begin</span>(); iit != (*it).<span class="pl-c1">end</span>(); ++iit)
      {
        std::cout &lt;&lt; *iit &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>; 
      }
  }
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;

  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>-- Iterating through with generic for_each: <span class="pl-pds">"</span></span>;
  <span class="pl-c1">std::for_each</span>(v_chunks.<span class="pl-c1">begin</span>(), v_chunks.<span class="pl-c1">end</span>(),
    [](chunked_container::<span class="pl-c1">chunk_t</span> chunk)
    {
      <span class="pl-c1">std::for_each</span>(chunk.<span class="pl-c1">begin</span>(), chunk.<span class="pl-c1">end</span>(),
        [](<span class="pl-c1">uint16_t</span> v)
        {
          std::cout &lt;&lt; v &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>;
        });

      std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>| <span class="pl-pds">"</span></span>;
    });
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;

  <span class="pl-k">auto</span> chunk_size  = <span class="pl-c1">std::distance</span>(v_chunks.<span class="pl-c1">begin</span>(), v_chunks.<span class="pl-c1">end</span>());
                     <span class="pl-c"><span class="pl-c">//</span> --&gt; 128/(16/8) = 64</span>
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>-- Chunks size: <span class="pl-pds">"</span></span> &lt;&lt; chunk_size &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;

  <span class="pl-c"><span class="pl-c">//</span> Iterators on elements in a chunk:</span>
  <span class="pl-k">auto</span> first_chunk_elem = first_chunk.<span class="pl-c1">begin</span>();
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>First element: <span class="pl-pds">"</span></span> &lt;&lt; *first_chunk_elem &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;

  <span class="pl-c1">uint16_t</span> third_chunk_elem = first_chunk[<span class="pl-c1">2</span>];
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Third element: <span class="pl-pds">"</span></span> &lt;&lt; third_chunk_elem &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;

  <span class="pl-c"><span class="pl-c">//</span> Pointer to data in second chunk:</span>
  <span class="pl-c1">uint16_t</span> *chunk_1_data = v_chunks[<span class="pl-c1">1</span>].<span class="pl-c1">data</span>();
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Pointer to data in second chunk (should be the third element with chunksize 2): <span class="pl-pds">"</span></span> &lt;&lt; *chunk_1_data &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;

  <span class="pl-c"><span class="pl-c">//</span> Pointer to data in third chunk (= end pointer of data in second chunk):</span>
  <span class="pl-c1">uint16_t</span> *chunk_2_data = v_chunks[<span class="pl-c1">2</span>].<span class="pl-c1">data</span>();
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Pointer to data in third chunk (should be the fifth element with chunksize 2): <span class="pl-pds">"</span></span> &lt;&lt; *chunk_2_data &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;

}</pre></div>

<p>Output:</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-k">&gt;</span> make
clang++ --std=c++11 -Wall -pthread -O0 -g main.cc
./a.out
-- Creation: --
Created new array with: 1
Appended to array: 2
Created new array with: 3
Appended to array: 4
Created new array with: 5
Appended to array: 6
Created new array with: 7
Appended to array: 8
Created new array with: 9
Appended to array: 10
-- Iterating through with custom <span class="pl-k">for</span>: 1 2 3 4 5 6 7 8 9 10
-- Iterating through with generic for_each: 1 2 <span class="pl-k">|</span> 3 4 <span class="pl-k">|</span> 5 6 <span class="pl-k">|</span> 7 8 <span class="pl-k">|</span> 9 10 <span class="pl-k">|</span>
-- Chunks size: 5
First element: 1
Third element: 3
Pointer to data <span class="pl-k">in</span> second chunk (should be the third element with chunksize 2): 3
Pointer to data <span class="pl-k">in</span> third chunk (should be the fifth element with chunksize 2): 5</pre></div>

<h3>
<a id="user-content-4-debugging" class="anchor" href="#4-debugging" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4. Debugging</h3>

<blockquote>
<p>Use gdb to debug the program implemented in the attached source file a-midterm/debug.cc. Running the program leads to a segfault.</p>

<p>Q: Use gdb to determine the source code location (stack trace) of the statement that causes the segmentation violation fault. Attach a screenshot or plaintext copy of gdb’s output.</p>
</blockquote>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>algorithm<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>numeric<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>list<span class="pl-pds">&gt;</span></span>

<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> List, <span class="pl-k">typename</span> UnaryPred&gt;
List &amp; <span class="pl-en">drop</span>(List &amp; l, UnaryPred condition) {
  <span class="pl-k">for</span> (<span class="pl-k">auto</span> i = l.<span class="pl-c1">begin</span>(); i != l.<span class="pl-c1">end</span>(); ++i) {
    <span class="pl-k">if</span> (<span class="pl-c1">condition</span>(*i)) {
      l.<span class="pl-c1">erase</span>(i);
    }
  }
  <span class="pl-k">return</span> l;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {

  std::list&lt;<span class="pl-k">int</span>&gt; l;

  <span class="pl-c1">std::generate_n</span>(
    <span class="pl-c1">std::back_inserter</span>(l), <span class="pl-c1">10</span>,
    []() { <span class="pl-k">return</span> <span class="pl-c1">std::rand</span>() % <span class="pl-c1">1024</span>; });

  <span class="pl-k">auto</span> &amp; ld = <span class="pl-c1">drop</span>(l, [](<span class="pl-k">int</span> x) -&gt; <span class="pl-k">bool</span> {
                        <span class="pl-k">return</span> x % <span class="pl-c1">3</span> == <span class="pl-c1">0</span>;
                      });

  <span class="pl-k">return</span> EXIT_SUCCESS;
}
</pre></div>

<p><strong>Answer</strong>: After fixing the obvious errors, like <code>return</code> in the lambda and <code>drop</code>, <code>vector -&gt; list</code> and a missing paramter in <code>generate_n</code>, we could compile the program. The problem is that the <code>erase</code> call in the <code>drop</code> function invalidates the current iterator <code>i</code>. That way we can't increment it.</p>

<p>Here is the <code>gdb</code> output.</p>

<p><a href="/Users/rewrite/Documents/university/master/semester-01/soft-dev/advanced-cpp/assignments/mid-term/4/gdb-output.png" target="_blank"><img src="/Users/rewrite/Documents/university/master/semester-01/soft-dev/advanced-cpp/assignments/mid-term/4/gdb-output.png" alt="gdb output" title="GDB Output" style="max-width:100%;"></a></p>

<p>The easy fix is to post-increment the iterator: <a href="/Users/rewrite/Documents/university/master/semester-01/soft-dev/advanced-cpp/assignments/mid-term/4/debug.cc">Code</a></p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> Vector, <span class="pl-k">typename</span> UnaryPred&gt;
Vector &amp; <span class="pl-en">drop</span>(Vector &amp; v, UnaryPred condition) {
  <span class="pl-k">for</span> (<span class="pl-k">auto</span> i = v.<span class="pl-c1">begin</span>(); i != v.<span class="pl-c1">end</span>(); ++i) {
    <span class="pl-k">if</span> (<span class="pl-c1">condition</span>(*i)) {
      v.<span class="pl-c1">erase</span>((i++));
    }
  }
  <span class="pl-k">return</span> v;
}</pre></div>

<h3>
<a id="user-content-5-algorithms-function-templates-type-deduction" class="anchor" href="#5-algorithms-function-templates-type-deduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5. Algorithms, Function Templates, Type Deduction</h3>

<h4>
<a id="user-content-51-defining-functions" class="anchor" href="#51-defining-functions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5.1 Defining Functions</h4>

<blockquote>
<p>Implement a function interface <code>void log10(X)</code> that accepts a numeric value of type <code>X</code> and:</p>

<p>Q: Prints the base 10 logarithm of the value if it is an integer and
     prints the base 10 logarithm of the value’s square root if it is a floating point value</p>
</blockquote>

<p><strong>Answer</strong>: <a href="/Users/rewrite/Documents/university/master/semester-01/soft-dev/advanced-cpp/assignments/mid-term/5-1/log10/log10.cc">Code</a></p>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>algorithm<span class="pl-pds">&gt;</span></span>

<span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> X&gt;
<span class="pl-k">void</span> <span class="pl-en">log10</span>(X x)
{   
    <span class="pl-k">if</span> (std::is_integral&lt;X&gt;::value)
    {
      std::cout &lt;&lt; <span class="pl-c1">std::log10</span>(x) &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
    } <span class="pl-k">else</span>
    {
      std::cout &lt;&lt; <span class="pl-c1">std::log10</span>(<span class="pl-c1">std::sqrt</span>(x)) &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
    }


}

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">int</span> argc, <span class="pl-k">char</span> <span class="pl-k">const</span> *argv[])
{
  <span class="pl-k">int</span>   i = <span class="pl-c1">10</span>;
  <span class="pl-k">float</span> f = <span class="pl-c1">10.0</span>;
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>int: <span class="pl-pds">"</span></span>;
  <span class="pl-c1">log10</span>(i);
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>double: <span class="pl-pds">"</span></span>;
  <span class="pl-c1">log10</span>(f);
  <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<p><em>Output</em>:</p>

<div class="highlight highlight-source-shell"><pre>int: 1
double: 0.5</pre></div>

<blockquote>
<p>Q: Implement a function interface <code>void print_walk(T begin, T end)</code> that accepts a range of iterators of type T and prints all values in the range. In this, the iteration order depends on the iterator type:</p>

<ul>
<li>for random-access iterators, tha order should be (pseudo) random but every element in the range must only be printed once</li>
<li>for input iterators, elements are printed in order from begin to end-1</li>
<li>for bidirectional iterators, elements are printed in reverse order from end-1 to begin</li>
</ul>
</blockquote>

<p><strong>Answer</strong>: <a href="/Users/rewrite/Documents/university/master/semester-01/soft-dev/advanced-cpp/assignments/mid-term/5-1/print-walk/print-walk.cc">Code</a></p>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>algorithm<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iterator<span class="pl-pds">&gt;</span></span>

#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>vector<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>list<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>sstream<span class="pl-pds">&gt;</span></span>

<span class="pl-c"><span class="pl-c">//</span> using dispatcher function from cppreference</span>

<span class="pl-k">template </span>&lt;<span class="pl-k">class</span> <span class="pl-en">RandomAccess</span>&gt;
<span class="pl-k">void</span> <span class="pl-en">print_walk</span>(RandomAccess begin, RandomAccess end, std::random_access_iterator_tag)
{
  <span class="pl-c1">std::random_shuffle</span>(begin,end);
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>RandomAccess Iterator:  <span class="pl-pds">"</span></span>;
  <span class="pl-c1">std::copy</span>(begin, end, std::ostream_iterator&lt;<span class="pl-k">typename</span> RandomAccess::value_type&gt;(std::cout, <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>));
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;

}

<span class="pl-k">template </span>&lt;<span class="pl-k">class</span> <span class="pl-en">BiDirectional</span>&gt;
<span class="pl-k">void</span> <span class="pl-en">print_walk</span>(BiDirectional begin, BiDirectional end, std::bidirectional_iterator_tag)
{
  <span class="pl-c1">std::reverse</span>(begin, end);
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>BiDirectional Iterator: <span class="pl-pds">"</span></span>;
  <span class="pl-c1">std::copy</span>(begin, end, std::ostream_iterator&lt;<span class="pl-k">typename</span> BiDirectional::value_type&gt;(std::cout, <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>));
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}

<span class="pl-k">template </span>&lt;<span class="pl-k">class</span> <span class="pl-en">Input</span>&gt;
<span class="pl-k">void</span> <span class="pl-en">print_walk</span>(Input begin, Input end, std::input_iterator_tag)
{
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Input Iterator:         <span class="pl-pds">"</span></span>;
  <span class="pl-c1">std::copy</span>(begin, end, std::ostream_iterator&lt;<span class="pl-k">typename</span> Input::value_type&gt;(std::cout, <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>));
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}

<span class="pl-k">template</span>&lt; <span class="pl-k">class</span> <span class="pl-en">Iter</span> &gt;
<span class="pl-k">void</span> <span class="pl-en">print_walk</span>(Iter first, Iter last)
{
    <span class="pl-c1">print_walk</span>(first, last,
        <span class="pl-k">typename</span> std::iterator_traits&lt;Iter&gt;::<span class="pl-c1">iterator_category</span>());
}


<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">int</span> argc, <span class="pl-k">char</span> <span class="pl-k">const</span> *argv[])
{
  std::vector&lt;<span class="pl-k">int</span>&gt;       v  { <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span> };
  std::list&lt;<span class="pl-k">int</span>&gt;         l  { <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span> };

  std::istringstream <span class="pl-smi">s</span>(<span class="pl-s"><span class="pl-pds">"</span>0123456789<span class="pl-pds">"</span></span>);
  std::istream_iterator&lt;<span class="pl-k">char</span>&gt; eos;
  std::istream_iterator&lt;<span class="pl-k">char</span>&gt; <span class="pl-c1">isi</span>(s);

  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Vector          is a  <span class="pl-pds">"</span></span>; 
  <span class="pl-c1">print_walk</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>());
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>List            is a  <span class="pl-pds">"</span></span>;
  <span class="pl-c1">print_walk</span>(l.<span class="pl-c1">begin</span>(), l.<span class="pl-c1">end</span>());
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>IStreamIterator is an <span class="pl-pds">"</span></span>;
  <span class="pl-c1">print_walk</span>(isi, eos);

  <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<p><em>Output</em>:</p>

<div class="highlight highlight-source-shell"><pre>Vector          is a  RandomAccess Iterator:  4 3 7 8 0 5 2 1 6 9 
List            is a  BiDirectional Iterator: 9 8 7 6 5 4 3 2 1 0 
IStreamIterator is an Input Iterator:         0 1 2 3 4 5 6 7 8 9</pre></div>

<h3>
<a id="user-content-6-stl-compatible-sequence-containers" class="anchor" href="#6-stl-compatible-sequence-containers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>6. STL-Compatible Sequence Containers</h3>

<h4>
<a id="user-content-61-lazy-sequence-container" class="anchor" href="#61-lazy-sequence-container" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>6.1 Lazy Sequence Container</h4>

<h3>
<a id="user-content-7-thread-safety" class="anchor" href="#7-thread-safety" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>7. Thread-Safety</h3>

<h4>
<a id="user-content-71-parallelism-and-stl-containers" class="anchor" href="#71-parallelism-and-stl-containers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>7.1 Parallelism and STL Containers</h4>

<blockquote>
<p>Given the following operations on an instance of <code>std::vector</code>, consider operation in the same table row to be executed by multiple threads in parallel:</p>

<div class="highlight highlight-source-c++"><pre><span class="pl-c"><span class="pl-c">//</span> Shared vector instance accessed by thread A and thread B:</span>
std::vector&lt;<span class="pl-k">int</span>&gt; v;

<span class="pl-c"><span class="pl-c">//</span> thread A:                    | thread B:</span>
<span class="pl-c">// =============================|==============================</span>
   std::vector&lt;<span class="pl-k">int</span>&gt; a;          | std::vector&lt;<span class="pl-k">int</span>&gt; b;           (<span class="pl-c1">1</span>)
<span class="pl-c"><span class="pl-c">//</span> -----------------------------+------------------------------</span>
   <span class="pl-k">int</span> xa = v[<span class="pl-c1">3</span>];               | <span class="pl-k">int</span> xb = v[<span class="pl-c1">4</span>];                (<span class="pl-c1">2</span>)
<span class="pl-c"><span class="pl-c">//</span> -----------------------------+------------------------------</span>
   v[<span class="pl-c1">3</span>] = <span class="pl-c1">123</span>;                  | v[<span class="pl-c1">4</span>] = <span class="pl-c1">345</span>;                   (<span class="pl-c1">3</span>)
<span class="pl-c"><span class="pl-c">//</span> -----------------------------+------------------------------</span>
   v[<span class="pl-c1">3</span>] = <span class="pl-c1">123</span>;                  | <span class="pl-k">int</span> xb = v[<span class="pl-c1">3</span>];                (<span class="pl-c1">4</span>)
<span class="pl-c"><span class="pl-c">//</span> -----------------------------+------------------------------</span>
   v.push_back(<span class="pl-c1">24</span>);             | v.size();                     (<span class="pl-c1">5</span>)
<span class="pl-c"><span class="pl-c">//</span> -----------------------------+------------------------------</span>
   v.back();                    | v.push_back(<span class="pl-c1">54</span>);              (<span class="pl-c1">6</span>)
<span class="pl-c"><span class="pl-c">//</span> -----------------------------+------------------------------</span>
   v.begin();                   | v.push_back(<span class="pl-c1">34</span>);              (<span class="pl-c1">7</span>)
<span class="pl-c"><span class="pl-c">//</span> -----------------------------+------------------------------</span>
   v.back();                    | v.pop_back();                 (<span class="pl-c1">8</span>)
<span class="pl-c"><span class="pl-c">//</span> -----------------------------+------------------------------</span></pre></div>

<p>Q: For every pair of operation on the same table row, give a brief explanation on the guarantees with respect to thread-safety according to the C++ standard.</p>
</blockquote>

<p><strong>Answer</strong>:</p>

<ul>
<li>(1) Ok, no shared resources used</li>
<li>(2) Ok, because <a href="http://en.cppreference.com/w/cpp/container">the Thread safety p.4</a> guarantees that iterator operations are safe for reading</li>
<li>(3) Ok, because <a href="http://en.cppreference.com/w/cpp/container">the Thread safety p.3</a> says it's ok to modify different elements in the same container</li>
<li>(4) Ok, but only because <code>v[3] = 123</code> is valid since step 3. Therefore there is no possiblity that this value is ambiguous</li>
<li>(5) Not ok, this is a modification of the container and the result of <code>size()</code> is dependent on the <code>push_back(24)</code>. <code>size()</code> may be <code>4</code>, or <code>5</code>
</li>
<li>(6) Not ok, same problem as in (5), <code>back()</code> is dependent on <code>push_back(54)</code>
</li>
<li>(7) Ok, because <code>begin()</code> returns the reference on the first element of the vector and does not change if an element is appended</li>
<li>(8) Not ok, same problem as in (5) and (6), <code>back()</code> is dependent on <code>pop_back()</code>
</li>
</ul>

<h4>
<a id="user-content-72-producer-consumer-problem" class="anchor" href="#72-producer-consumer-problem" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>7.2 Producer-Consumer Problem</h4>

<blockquote>
<p>Simply put, one thread is producing goods and another thread is consuming goods. We want the consumer thread to wait using a condition variable, and we want goods.push(i) to be mutually exclusive to goods.pop().</p>

<p>We are letting c++ and c– be surrogates for this mutual exclusion, since we can easily check if we correctly end up with 0 in the end.</p>

<p>Run the code as it is <em>(with -pthread flag)</em>, and you will see that the net value is way off:</p>
</blockquote>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>thread<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>condition_variable<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>mutex<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>chrono<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>queue<span class="pl-pds">&gt;</span></span>

<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
    <span class="pl-k">int</span> c = <span class="pl-c1">0</span>;
    <span class="pl-k">bool</span> done = <span class="pl-c1">false</span>;
    queue&lt;<span class="pl-k">int</span>&gt; goods;

    thread <span class="pl-smi">producer</span>([&amp;]() {
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; <span class="pl-c1">500</span>; ++i) {
            goods.<span class="pl-c1">push</span>(i);
            c++;
        }

        done = <span class="pl-c1">true</span>;
    });

    thread <span class="pl-smi">consumer</span>([&amp;]() {
        <span class="pl-k">while</span> (!done) {
            <span class="pl-k">while</span> (!goods.<span class="pl-c1">empty</span>()) {
                goods.<span class="pl-c1">pop</span>();
                c--;
            }
        }
    });

    producer.<span class="pl-c1">join</span>();
    consumer.<span class="pl-c1">join</span>();
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Net: <span class="pl-pds">"</span></span> &lt;&lt; c &lt;&lt; endl;
}</pre></div>

<blockquote>
<p>Q: (There was no question, but if we would have to fix the implementation)</p>
</blockquote>

<p><strong>Answer</strong>: Simply replace <code>int c = 0;</code> with <code>std::atomic&lt;int&gt; c(0);</code> and add the header <code>#include &lt;atomic&gt;</code>. This ensures that the counter will be updated thread-safe and lock-free.
<a href="/Users/rewrite/Documents/university/master/semester-01/soft-dev/advanced-cpp/assignments/mid-term/7-2/consumer-producer.cc">Code</a></p>
</article></body></html>